<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<diagram program="umlet" version="14.3.0">
  <zoom_level>10</zoom_level>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>220</x>
      <y>0</y>
      <w>140</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>
m1=
m2=
m2pos=-5,7
lt=|&lt;..
transparency=100
r1pos=-5,7
&lt;&lt;include&gt;&gt;
lw=2.0
</panel_attributes>
    <additional_attributes>120.0;20.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLNote</id>
    <coordinates>
      <x>70</x>
      <y>120</y>
      <w>140</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>Note
fontsize=13
bg=#003366
</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>260</x>
      <y>260</y>
      <w>20</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>
bg=#999966
layer=-2</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>220</x>
      <y>220</y>
      <w>100</w>
      <h>30</h>
    </coordinates>
    <panel_attributes>_O1_
bg=#999933</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLActor</id>
    <coordinates>
      <x>10</x>
      <y>50</y>
      <w>60</w>
      <h>110</h>
    </coordinates>
    <panel_attributes>Actor
bg=#999966</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLFrame</id>
    <coordinates>
      <x>10</x>
      <y>470</y>
      <w>180</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>ref
bg=#313131</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>260</x>
      <y>240</y>
      <w>30</w>
      <h>120</h>
    </coordinates>
    <panel_attributes>lt=.

layer=-3</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLFrame</id>
    <coordinates>
      <x>10</x>
      <y>270</y>
      <w>180</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>opt
bg=#b1b1b1</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLFrame</id>
    <coordinates>
      <x>10</x>
      <y>370</y>
      <w>180</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>loop
bg=#515151</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>80</x>
      <y>40</y>
      <w>150</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>lt=-&gt;&gt;
1.1  sync call</panel_attributes>
    <additional_attributes>10.0;20.0;130.0;20.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>210</x>
      <y>40</y>
      <w>150</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>lt=&lt;-
1.2  async return</panel_attributes>
    <additional_attributes>10.0;20.0;130.0;20.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>200</x>
      <y>400</y>
      <w>200</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;-
1.1  a rose is a rose
</panel_attributes>
    <additional_attributes>30.0;40.0;70.0;40.0;70.0;10.0;10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>200</x>
      <y>440</y>
      <w>190</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=&lt;&lt;-
1.2  a rose is a rose

group=1</panel_attributes>
    <additional_attributes>20.0;40.0;60.0;40.0;60.0;10.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>200</x>
      <y>460</y>
      <w>20</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>
bg=#999966
layer=-1
group=1</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLFrame</id>
    <coordinates>
      <x>10</x>
      <y>170</y>
      <w>180</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>alt
bg=#e1e1e1</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Text</id>
    <coordinates>
      <x>310</x>
      <y>480</y>
      <w>70</w>
      <h>30</h>
    </coordinates>
    <panel_attributes>*Module*
style=wordwrap
</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>40</x>
      <y>10</y>
      <w>190</w>
      <h>30</h>
    </coordinates>
    <panel_attributes>lt=&lt;..</panel_attributes>
    <additional_attributes>10.0;10.0;170.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>340</x>
      <y>150</y>
      <w>30</w>
      <h>200</h>
    </coordinates>
    <panel_attributes>lt=&lt;..
fg=#003366
</panel_attributes>
    <additional_attributes>10.0;180.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Text</id>
    <coordinates>
      <x>220</x>
      <y>480</y>
      <w>100</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>This is a text element to place text anywhere.
style=wordwrap
</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <type>CustomElementImpl</type>
    <coordinates>
      <x>220</x>
      <y>120</y>
      <w>141</w>
      <h>41</h>
    </coordinates>
    <panel_attributes>// Modify the text below and
// observe the element preview.
fontsize=13
/*Hello,*/ _World!_

bg=#003366</panel_attributes>
    <additional_attributes/>
    <custom_code>//Modify the code below to define the element's behavior.
//
//Example:  Change the line
//  y += printCenter(textline,y);
//to
//  y += 2*printCenter(textline,y);
//and observe the element preview.
try
{
    int y = textHeight();
    Polygon poly = new Polygon();
    poly.addPoint(width-12,0);
    poly.addPoint(width-12,12);
	 poly.addPoint(width,12);
	 poly.addPoint(width,height);
	 poly.addPoint(0,height); 
    poly.addPoint(0,0);
    drawPolygon(poly);

    Polygon poly1 = new Polygon();
	 poly1.addPoint(width-12,0);
	 poly1.addPoint(width-12,12);
	 poly1.addPoint(width,12);

    drawPolygon(poly1);

    // (1) Try to find global parameters such as, font size, etc.
    double fsize = com.baselet.control.HandlerElementMap.getHandlerForElement(this).getFontHandler().getFontSize();
    boolean fflag = false;
    int newFSize = 14;

    for(String textline : textlines)
    {
       String substring = textline;
       int x = 5;
       char c1;
       boolean gbflag = false;
       boolean giflag = false;
       boolean guflag = false;

       if(substring.startsWith("fontsize="))
       {
            substring = substring.substring("fontsize=".length(),substring.length());

            try
            {
                newFSize = Integer.parseInt(substring.trim());
            }
            catch(NumberFormatException ex)
            {
                newFSize = (int)fsize;
            }

            com.baselet.control.HandlerElementMap.getHandlerForElement(this).getFontHandler().setFontSize((double)newFSize);
            fflag = true;

            continue;
       }

       if(fflag)
       {    // The next sentence after Bumping into changing of a font size. 
            y+=newFSize-fsize;
            fflag = false;
       }

        while(!substring.isEmpty() &amp;&amp; ((c1=substring.charAt(0))=='*' || c1=='/' || c1=='_') &amp;&amp; substring.charAt(substring.length()-1)==c1 &amp;&amp; ((substring.length() - substring.replace(c1+"","").length())==2))
        {   // (2) Find all global parameters of a line, such as, bold, italic, and an underline.
            // That will break if one of the word contains one of '*'; or '/'; or '_'.
           substring = substring.substring(1,substring.length()-1);

           switch(c1)
           {
               case '*':
               {
                    gbflag = true;

                    break;
               }
               case '/':
               {
                    giflag = true;

                    break;
               }
               case '_':
               {
                   guflag = true;

                   break;
               }
           }
        }

        String[] subs = substring.split(" ");

        for(int i=0;i&lt;subs.length;i++)    
        {
            String sub = subs[i];

            char lc1;
            boolean lbflag = false;
            boolean liflag = false;
            boolean luflag = false;

            while(!sub.isEmpty() &amp;&amp; ((lc1=sub.charAt(0))=='*' || lc1=='/' || lc1=='_') &amp;&amp; sub.charAt(sub.length()-1)==lc1)
            {
                sub = sub.substring(1,sub.length()-1);

                switch(lc1)
                {
                    case '*':
                    {
                        lbflag = true;

                        break;
                    }
                    case '/':
                    {
                        liflag = true;

                        break;
                    }
                    case '_':
                    {
                        luflag = true;

                        break;
                    }
                }
            }

            String word = lbflag || gbflag ? '*'+sub+'*' : sub;
            word = liflag || giflag ? '/'+word+'/' : word;
            word = luflag || guflag ? '_'+word+'_' : word;

            x += textWidth(sub,true);
            
            if(!sub.trim().isEmpty())
            {   // No need to print empty words.
                // AlignHorizontal.RIGHT, that's to workaround an internal bug.
                com.baselet.control.HandlerElementMap.getHandlerForElement(this).getFontHandler().writeText(g2,word,(int)(x*zoom),(int)(y*zoom),com.baselet.control.enums.AlignHorizontal.RIGHT,true);
            }

            if(i&lt;subs.length-1)
            {   // Move the cusrsor one space right.
                x += textWidth(" ",true);
            }           
        }

        y += printLeft("",y);
        com.baselet.control.HandlerElementMap.getHandlerForElement(this).getFontHandler().setFontSize(fsize);
    }
}
catch(Exception e)
{}</custom_code>
  </element>
  <element>
    <type>CustomElementImpl</type>
    <coordinates>
      <x>220</x>
      <y>180</y>
      <w>101</w>
      <h>31</h>
    </coordinates>
    <panel_attributes>// That takes effect globaly.
// That must come first. 
gradient=btt
gradient=true
// Those settings are at the sentence level.
halign=center
fontsize=14
_Web_

bg=#999933
</panel_attributes>
    <additional_attributes/>
    <custom_code>//Modify the code below to define the element's behavior.
//
//Example:  Change the line
//  y += printCenter(textline,y);
//to
//  y += 2*printCenter(textline,y);
//and observe the element preview.
try
{
    int y = textHeight();

    // (1) Try to find global parameters such as, font size, etc.
    double fsize = com.baselet.control.HandlerElementMap.getHandlerForElement(this).getFontHandler().getFontSize();
    boolean fflag = false;
    boolean calign = false;
    boolean ltr = true;
    boolean ttb = true;
    boolean frame = true;
    int newFSize = 14;

    for(String textline : textlines)
    {
       String substring = textline;
       int x = 10;
       char c1;
       boolean gbflag = false;
       boolean giflag = false;
       boolean guflag = false;

       if(substring.startsWith("fontsize="))
       {
            substring = substring.substring("fontsize=".length(),substring.length());

            try
            {
                newFSize = Integer.parseInt(substring.trim());
            }
            catch(NumberFormatException ex)
            {
                newFSize = (int)fsize;
            }

            com.baselet.control.HandlerElementMap.getHandlerForElement(this).getFontHandler().setFontSize((double)newFSize);
            fflag = true;

            continue;
       }
       else if(substring.startsWith("halign=center"))
       {
           calign = true;

           continue;
       }
       else if(substring.startsWith("gradient=rtl"))
       {
           ltr = false;
                   
           continue;
       }
       else if(substring.startsWith("gradient=btt"))
       {
           ttb = false;

           continue;
       }
       else if(substring.startsWith("gradient=true"))
       {    // Takes effect, globaly.
            int x1 =0, x2 = width, y1 = 0,y2 = height;
            
            if(!ltr)
            {
                x1 = width;
                x2 = 0;
            }
            
            if(!ttb)
            {
            	 x1 = width;
            	 x2 = width;
                y1 = height;
                y2 = 0;
            }

				int xstart = frame ? 1 : 0;
				int ystart = frame ? 1 : 0;
            int twidth = frame ? width-1 : width;
            int theight = frame ? height-1 : height;
            
            GradientPaint blueToBlack = new GradientPaint(x1,y1,bgColor.brighter(),x2,y2,bgColor);
            g2.draw(new Rectangle(0,0,width,height));
            g2.setPaint(blueToBlack);
            g2.fill(new java.awt.geom.Rectangle2D.Double(xstart,ystart,twidth,theight));
            g2.setColor(fgColor);

            continue;
       }
       else if(substring.startsWith("gradient=false"))
       {
       		drawRectangle(0,0,width,height);

       		continue;
       }
       else if(substring.startsWith("frame=false"))
       {
       		frame = false;
       }

       if(fflag)
       {    // The next sentence after Bumping into changing of a font size. 
            y+=newFSize-fsize;
            fflag = false;
       }
       
       if(calign)
       {	  // The next sentence after Bumping into align setting. 
           int w = textWidth(substring,true);
           x = (width-w)/2;
           calign = false;
       }

        while(!substring.isEmpty() &amp;&amp; ((c1=substring.charAt(0))=='*' || c1=='/' || c1=='_') &amp;&amp; substring.charAt(substring.length()-1)==c1 &amp;&amp; ((substring.length() - substring.replace(c1+"","").length())==2))
        {   // (2) Find all global parameters of a line, such as, bold, italic, and an underline.
            // That will break if one of the word contains one of '*'; or '/'; or '_'.
           substring = substring.substring(1,substring.length()-1);

           switch(c1)
           {
               case '*':
               {
                    gbflag = true;

                    break;
               }
               case '/':
               {
                    giflag = true;

                    break;
               }
               case '_':
               {
                   guflag = true;

                   break;
               }
           }
        }

        String[] subs = substring.split(" ");

        for(int i=0;i&lt;subs.length;i++)    
        {
            String sub = subs[i];

            char lc1;
            boolean lbflag = false;
            boolean liflag = false;
            boolean luflag = false;

            while(!sub.isEmpty() &amp;&amp; ((lc1=sub.charAt(0))=='*' || lc1=='/' || lc1=='_') &amp;&amp; sub.charAt(sub.length()-1)==lc1)
            {
                sub = sub.substring(1,sub.length()-1);

                switch(lc1)
                {
                    case '*':
                    {
                        lbflag = true;

                        break;
                    }
                    case '/':
                    {
                        liflag = true;

                        break;
                    }
                    case '_':
                    {
                        luflag = true;

                        break;
                    }
                }
            }

            String word = lbflag || gbflag ? '*'+sub+'*' : sub;
            word = liflag || giflag ? '/'+word+'/' : word;
            word = luflag || guflag ? '_'+word+'_' : word;

            x += textWidth(sub,true);
            
            if(!sub.trim().isEmpty())
            {   // No need to print empty words.
                // AlignHorizontal.RIGHT, that's to workaround an internal bug.
                com.baselet.control.HandlerElementMap.getHandlerForElement(this).getFontHandler().writeText(g2,word,(int)(x*zoom),(int)(y*zoom),com.baselet.control.enums.AlignHorizontal.RIGHT,true);
            }

            if(i&lt;subs.length-1)
            {   // Move the cusrsor one space right.
                x += textWidth(" ",true);
            }           
        }

        y += printLeft("",y);
        com.baselet.control.HandlerElementMap.getHandlerForElement(this).getFontHandler().setFontSize(fsize);
    }
}
catch(Exception e)
{}</custom_code>
  </element>
  <element>
    <type>CustomElementImpl</type>
    <coordinates>
      <x>60</x>
      <y>70</y>
      <w>151</w>
      <h>41</h>
    </coordinates>
    <panel_attributes>// Holds the direction of the arrow, ltr for -&gt;,
// or, rtl for &lt;-
dir=ltr
//dir=rtl

fontsize=13

// Write your own prefix.
//prefix=2.0

/*Hello* World!/
/Automatic _*numerator*_/

</panel_attributes>
    <additional_attributes/>
    <custom_code>//Modify the code below to define the element's behavior.
//
//Example:  Change the line
//  y += printCenter(textline,y);

try
{
    String tag = getSetting("dir");

    if(tag==null)
    {   // Go to default.
        tag = "ltr";
    }

    setName(tag);

    int y = textHeight();
    double min = 0.0;

    if(tag.equals("ltr"))
    {
        drawLine(0,y+2,width-12,y+2);
        Polygon poly = new Polygon();
        poly.addPoint(width-12,y-4);
        poly.addPoint(width,y+2);
        poly.addPoint(width-12,y+8);
        drawPolygon(poly);
    }
    else
    {
        drawLine(0,y+2,width,y+2);
        drawLine(0,y+2,12,y-4);
        drawLine(0,y+2,12,y+8);
    }

    Point p = getLocationOnScreen();
    String sp = p.getY()+"_"+p.getX();
    String key = ""+Objects.hash(this);

    Map&lt;String,String&gt; map = (Map&lt;String,String&gt;)System.getProperties().get("arrows_map");
    Map&lt;String,javax.swing.JComponent&gt; status = (Map&lt;String,javax.swing.JComponent&gt;)System.getProperties().get("status_map");

    if(map==null)
    {
        map = new java.util.concurrent.ConcurrentHashMap();
        status = new java.util.concurrent.ConcurrentHashMap();
        System.getProperties().put("arrows_map",map);
        System.getProperties().put("status_map",status);
    }

    String prefix = "";
    double xcounter = 0;
    double ycounter = 0;

    map.put(key,sp);
    status.put(key,this);

    Map&lt;String,String&gt; temp = new HashMap();

    for(Map.Entry&lt;String,String&gt; entry: map.entrySet())
    {
        String k = entry.getKey();
        String point = map.get(k);
        temp.put(point,k);
    }

    Map&lt;String,String&gt; treeMap = new TreeMap&lt;String,String&gt;();
    treeMap.putAll(temp);

    for(Map.Entry&lt;String,String&gt; entry : treeMap.entrySet())
    {
        String k = entry.getValue();

        javax.swing.JComponent comp = status.get(k);

        if(comp==null || comp.getParent()==null || !comp.isVisible())
        {
            continue;
        }

        String point = entry.getKey();
        String sx = point.substring(point.indexOf('_')+1);
        double d = Double.parseDouble(sx);

        String ctag = comp.getName();

        if(ctag==null)
        {   // That shouldn't happen.
            ctag = "ltr";
        }

        if(ctag.equals("ltr"))
        {
            if(d&gt;min &amp;&amp; min==0.0)
            {	// First time.
                xcounter++;
                min = d;
            }
            else if(d&gt;=min-2 &amp;&amp; d&lt;=min+2)
            {
                xcounter++;
                ycounter = 0;
            }
            else if(d&gt;min+2)
            {
                ycounter++;
            }
        }
        else
        {
            if(d&gt;min &amp;&amp; min==0.0)
            {	// First time.
                xcounter++;
                ycounter++;
                min = d;
            }
            else if(d&gt;min+2)
            {
                ycounter+=1;
            }
        }

        if(k.equals(key))
        {
            prefix = ""+(int)xcounter+'.'+(int)ycounter;
        }
    }

    String manuelPrefix = getSetting("prefix");
    String fs = getSetting("fontsize");

    if(fs!=null)
    {
        com.baselet.control.HandlerElementMap.getHandlerForElement(this).getFontHandler().setFontSize(Double.parseDouble(fs));
    }

    if(manuelPrefix!=null)
    {
        prefix = manuelPrefix;
    }

    boolean first = true;

    for(String textline : textlines)
    {
        char c1;
        boolean gbflag = false;
        boolean giflag = false;
        boolean guflag = false;

        if(textline.startsWith("prefix=") || textline.startsWith("fontsize=") || textline.startsWith("dir="))
        {
            continue;
        }

        while(!textline.isEmpty() &amp;&amp; ((c1=textline.charAt(0))=='*' || c1=='/' || c1=='_') &amp;&amp; textline.charAt(textline.length()-1)==c1 &amp;&amp; ((textline.length() - textline.replace(c1+"","").length())==2))
        {   // Find all global parameters of a line, such as, bold, italic, and an underline.
            // That will break if one of the word contains one of '*'; or '/'; or '_'.
            textline = textline.substring(1,textline.length()-1);

            switch(c1)
            {
                case '*':
                {
                    gbflag = true;

                    break;
                }
                case '/':
                {
                    giflag = true;

                    break;
                }
                case '_':
                {
                    guflag = true;

                    break;
                }
            }
        }

        int x = (width-textWidth(first ? prefix+"  "+textline : textline,true))/2;

        if(first)
        {
            if(!prefix.isEmpty())
            {
                x+=textWidth(prefix+"  ",true);
                com.baselet.control.HandlerElementMap.getHandlerForElement(this).getFontHandler().writeText(g2,"/*"+prefix+"*/",(int)(x*zoom),(int)(y*zoom),com.baselet.control.enums.AlignHorizontal.RIGHT,true);
                x+=5;
            }

            first = false;
        }
        else
        {
            y+=textHeight();
        }

        String[] subs = textline.split(" ");

        for(int i=0;i&lt;subs.length;i++)    
        {
            String sub = subs[i];

            char lc1;
            boolean lbflag = false;
            boolean liflag = false;
            boolean luflag = false;

            while(!sub.isEmpty() &amp;&amp; ((lc1=sub.charAt(0))=='*' || lc1=='/' || lc1=='_') &amp;&amp; sub.charAt(sub.length()-1)==lc1)
            {
                sub = sub.substring(1,sub.length()-1);

                switch(lc1)
                {
                    case '*':
                    {
                        lbflag = true;

                        break;
                    }
                    case '/':
                    {
                        liflag = true;

                        break;
                    }
                    case '_':
                    {
                        luflag = true;

                        break;
                    }
                }
            }

            String word = lbflag || gbflag ? '*'+sub+'*' : sub;
            word = liflag || giflag ? '/'+word+'/' : word;
            word = luflag || guflag ? '_'+word+'_' : word;

            x += textWidth(sub,true);

            if(lbflag || gbflag)
            {
                x+=(word.length()/3);
            }

            if(!sub.trim().isEmpty())
            {   // No need to print empty words.
                // AlignHorizontal.RIGHT, that's to workaround an internal bug.
                com.baselet.control.HandlerElementMap.getHandlerForElement(this).getFontHandler().writeText(g2,word,(int)(x*zoom),(int)(y*zoom),com.baselet.control.enums.AlignHorizontal.RIGHT,true);
            }

            if(i&lt;subs.length-1)
            {   // Move the cusrsor one space right.
                x += textWidth(" ",true);
            }           
        }
    }
}
catch(Exception e)
{}</custom_code>
  </element>
  <element>
    <type>CustomElementImpl</type>
    <coordinates>
      <x>220</x>
      <y>70</y>
      <w>161</w>
      <h>51</h>
    </coordinates>
    <panel_attributes>// Holds the direction of the arrow, ltr for -&gt;,
// or, rtl for &lt;-
dir=rtl
//dir=ltr

fontsize=13

// Write your own prefix.
//prefix=2.0

/*Hello* World!/
/Automatic _*numerator*_/

</panel_attributes>
    <additional_attributes/>
    <custom_code>//Modify the code below to define the element's behavior.
//
//Example:  Change the line
//  y += printCenter(textline,y);

try
{
    String tag = getSetting("dir");

    if(tag==null)
    {   // Go to default.
        tag = "ltr";
    }

    setName(tag);

    int y = textHeight();
    double min = 0.0;

    if(tag.equals("ltr"))
    {
        drawLine(0,y+2,width-12,y+2);
        Polygon poly = new Polygon();
        poly.addPoint(width-12,y-4);
        poly.addPoint(width,y+2);
        poly.addPoint(width-12,y+8);
        drawPolygon(poly);
    }
    else
    {
        drawLine(0,y+2,width,y+2);
        drawLine(0,y+2,12,y-4);
        drawLine(0,y+2,12,y+8);
    }

    Point p = getLocationOnScreen();
    String sp = p.getY()+"_"+p.getX();
    String key = ""+Objects.hash(this);

    Map&lt;String,String&gt; map = (Map&lt;String,String&gt;)System.getProperties().get("arrows_map");
    Map&lt;String,javax.swing.JComponent&gt; status = (Map&lt;String,javax.swing.JComponent&gt;)System.getProperties().get("status_map");

    if(map==null)
    {
        map = new java.util.concurrent.ConcurrentHashMap();
        status = new java.util.concurrent.ConcurrentHashMap();
        System.getProperties().put("arrows_map",map);
        System.getProperties().put("status_map",status);
    }

    String prefix = "";
    double xcounter = 0;
    double ycounter = 0;

    map.put(key,sp);
    status.put(key,this);

    Map&lt;String,String&gt; temp = new HashMap();

    for(Map.Entry&lt;String,String&gt; entry: map.entrySet())
    {
        String k = entry.getKey();
        String point = map.get(k);
        temp.put(point,k);
    }

    Map&lt;String,String&gt; treeMap = new TreeMap&lt;String,String&gt;();
    treeMap.putAll(temp);

    for(Map.Entry&lt;String,String&gt; entry : treeMap.entrySet())
    {
        String k = entry.getValue();

        javax.swing.JComponent comp = status.get(k);

        if(comp==null || comp.getParent()==null || !comp.isVisible())
        {
            continue;
        }

        String point = entry.getKey();
        String sx = point.substring(point.indexOf('_')+1);
        double d = Double.parseDouble(sx);

        String ctag = comp.getName();

        if(ctag==null)
        {   // That shouldn't happen.
            ctag = "ltr";
        }

        if(ctag.equals("ltr"))
        {
            if(d&gt;min &amp;&amp; min==0.0)
            {	// First time.
                xcounter++;
                min = d;
            }
            else if(d&gt;=min-2 &amp;&amp; d&lt;=min+2)
            {
                xcounter++;
                ycounter = 0;
            }
            else if(d&gt;min+2)
            {
                ycounter++;
            }
        }
        else
        {
            if(d&gt;min &amp;&amp; min==0.0)
            {	// First time.
                xcounter++;
                ycounter++;
                min = d;
            }
            else if(d&gt;min+2)
            {
                ycounter+=1;
            }
        }

        if(k.equals(key))
        {
            prefix = ""+(int)xcounter+'.'+(int)ycounter;
        }
    }

    String manuelPrefix = getSetting("prefix");
    String fs = getSetting("fontsize");

    if(fs!=null)
    {
        com.baselet.control.HandlerElementMap.getHandlerForElement(this).getFontHandler().setFontSize(Double.parseDouble(fs));
    }

    if(manuelPrefix!=null)
    {
        prefix = manuelPrefix;
    }

    boolean first = true;

    for(String textline : textlines)
    {
        char c1;
        boolean gbflag = false;
        boolean giflag = false;
        boolean guflag = false;

        if(textline.startsWith("prefix=") || textline.startsWith("fontsize=") || textline.startsWith("dir="))
        {
            continue;
        }

        while(!textline.isEmpty() &amp;&amp; ((c1=textline.charAt(0))=='*' || c1=='/' || c1=='_') &amp;&amp; textline.charAt(textline.length()-1)==c1 &amp;&amp; ((textline.length() - textline.replace(c1+"","").length())==2))
        {   // Find all global parameters of a line, such as, bold, italic, and an underline.
            // That will break if one of the word contains one of '*'; or '/'; or '_'.
            textline = textline.substring(1,textline.length()-1);

            switch(c1)
            {
                case '*':
                {
                    gbflag = true;

                    break;
                }
                case '/':
                {
                    giflag = true;

                    break;
                }
                case '_':
                {
                    guflag = true;

                    break;
                }
            }
        }

        int x = (width-textWidth(first ? prefix+"  "+textline : textline,true))/2;

        if(first)
        {
            if(!prefix.isEmpty())
            {
                x+=textWidth(prefix+"  ",true);
                com.baselet.control.HandlerElementMap.getHandlerForElement(this).getFontHandler().writeText(g2,"/*"+prefix+"*/",(int)(x*zoom),(int)(y*zoom),com.baselet.control.enums.AlignHorizontal.RIGHT,true);
                x+=5;
            }

            first = false;
        }
        else
        {
            y+=textHeight();
        }

        String[] subs = textline.split(" ");

        for(int i=0;i&lt;subs.length;i++)    
        {
            String sub = subs[i];

            char lc1;
            boolean lbflag = false;
            boolean liflag = false;
            boolean luflag = false;

            while(!sub.isEmpty() &amp;&amp; ((lc1=sub.charAt(0))=='*' || lc1=='/' || lc1=='_') &amp;&amp; sub.charAt(sub.length()-1)==lc1)
            {
                sub = sub.substring(1,sub.length()-1);

                switch(lc1)
                {
                    case '*':
                    {
                        lbflag = true;

                        break;
                    }
                    case '/':
                    {
                        liflag = true;

                        break;
                    }
                    case '_':
                    {
                        luflag = true;

                        break;
                    }
                }
            }

            String word = lbflag || gbflag ? '*'+sub+'*' : sub;
            word = liflag || giflag ? '/'+word+'/' : word;
            word = luflag || guflag ? '_'+word+'_' : word;

            x += textWidth(sub,true);

            if(lbflag || gbflag)
            {
                x+=(word.length()/3);
            }

            if(!sub.trim().isEmpty())
            {   // No need to print empty words.
                // AlignHorizontal.RIGHT, that's to workaround an internal bug.
                com.baselet.control.HandlerElementMap.getHandlerForElement(this).getFontHandler().writeText(g2,word,(int)(x*zoom),(int)(y*zoom),com.baselet.control.enums.AlignHorizontal.RIGHT,true);
            }

            if(i&lt;subs.length-1)
            {   // Move the cusrsor one space right.
                x += textWidth(" ",true);
            }           
        }
    }
}
catch(Exception e)
{}</custom_code>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>200</x>
      <y>360</y>
      <w>20</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>
bg=#999966
layer=-1</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <type>CustomElementImpl</type>
    <coordinates>
      <x>210</x>
      <y>350</y>
      <w>201</w>
      <h>51</h>
    </coordinates>
    <panel_attributes>// Holds the direction of the arrow, ltr for -&gt;,
// or, rtl for &lt;-
dir=rtl
//dir=ltr

fontsize=13

// Write your own prefix.
//prefix=2.0

/*Hello* World!/
/Automatic _*numerator*_/

</panel_attributes>
    <additional_attributes/>
    <custom_code>//Modify the code below to define the element's behavior.
//
//Example:  Change the line
//  y += printCenter(textline,y);

try
{
    String tag = "ltr";
    setName(tag);

    int y = textHeight();
    double min = 0.0;

    drawLine(0,0,54,0);
    drawLine(54,0,54,height-18);
    drawLine(54,height-18,24,height-18);
    
    Polygon poly = new Polygon();
    poly.addPoint(23,height-24);
    poly.addPoint(11,height-18);
    poly.addPoint(23,height-12);
    drawPolygon(poly);

    Point p = getLocationOnScreen();
    String sp = p.getY()+"_"+p.getX();
    String key = ""+Objects.hash(this);

    Map&lt;String,String&gt; map = (Map&lt;String,String&gt;)System.getProperties().get("arrows_map");
    Map&lt;String,javax.swing.JComponent&gt; status = (Map&lt;String,javax.swing.JComponent&gt;)System.getProperties().get("status_map");

    if(map==null)
    {
        map = new java.util.concurrent.ConcurrentHashMap();
        status = new java.util.concurrent.ConcurrentHashMap();
        System.getProperties().put("arrows_map",map);
        System.getProperties().put("status_map",status);
    }

    String prefix = "";
    double xcounter = 0;
    double ycounter = 0;

    map.put(key,sp);
    status.put(key,this);

    Map&lt;String,String&gt; temp = new HashMap();

    for(Map.Entry&lt;String,String&gt; entry: map.entrySet())
    {
        String k = entry.getKey();
        String point = map.get(k);
        temp.put(point,k);
    }

    Map&lt;String,String&gt; treeMap = new TreeMap&lt;String,String&gt;();
    treeMap.putAll(temp);

    for(Map.Entry&lt;String,String&gt; entry : treeMap.entrySet())
    {
        String k = entry.getValue();

        javax.swing.JComponent comp = status.get(k);

        if(comp==null || comp.getParent()==null || !comp.isVisible())
        {
            continue;
        }

        String point = entry.getKey();
        String sx = point.substring(point.indexOf('_')+1);
        double d = Double.parseDouble(sx);

        String ctag = comp.getName();

        if(ctag==null)
        {   // That shouldn't happen.
            ctag = "ltr";
        }

        if(ctag.equals("ltr"))
        {
            if(d&gt;min &amp;&amp; min==0.0)
            {	// First time.
                xcounter++;
                min = d;
            }
            else if(d&gt;=min-2 &amp;&amp; d&lt;=min+2)
            {
                xcounter++;
                ycounter = 0;
            }
            else if(d&gt;min+2)
            {
                ycounter++;
            }
        }
        else
        {
            if(d&gt;min &amp;&amp; min==0.0)
            {	// First time.
                xcounter++;
                ycounter++;
                min = d;
            }
            else if(d&gt;min+2)
            {
                ycounter+=1;
            }
        }

        if(k.equals(key))
        {
            prefix = ""+(int)xcounter+'.'+(int)ycounter;
        }
    }

    String manuelPrefix = getSetting("prefix");
    String fs = getSetting("fontsize");

    if(fs!=null)
    {
        com.baselet.control.HandlerElementMap.getHandlerForElement(this).getFontHandler().setFontSize(Double.parseDouble(fs));
    }

    if(manuelPrefix!=null)
    {
        prefix = manuelPrefix;
    }

    boolean first = true;

    for(String textline : textlines)
    {
        char c1;
        boolean gbflag = false;
        boolean giflag = false;
        boolean guflag = false;

        if(textline.startsWith("prefix=") || textline.startsWith("fontsize=") || textline.startsWith("dir="))
        {
            continue;
        }

        while(!textline.isEmpty() &amp;&amp; ((c1=textline.charAt(0))=='*' || c1=='/' || c1=='_') &amp;&amp; textline.charAt(textline.length()-1)==c1 &amp;&amp; ((textline.length() - textline.replace(c1+"","").length())==2))
        {   // Find all global parameters of a line, such as, bold, italic, and an underline.
            // That will break if one of the word contains one of '*'; or '/'; or '_'.
            textline = textline.substring(1,textline.length()-1);

            switch(c1)
            {
                case '*':
                {
                    gbflag = true;

                    break;
                }
                case '/':
                {
                    giflag = true;

                    break;
                }
                case '_':
                {
                    guflag = true;

                    break;
                }
            }
        }

        int x = 58;

        if(first)
        {
            if(!prefix.isEmpty())
            {
                x+=textWidth(prefix+"  ",true);
                com.baselet.control.HandlerElementMap.getHandlerForElement(this).getFontHandler().writeText(g2,"/*"+prefix+"*/",(int)(x*zoom),(int)(y*zoom),com.baselet.control.enums.AlignHorizontal.RIGHT,true);
                x+=5;
            }

            first = false;
        }
        else
        {
            y+=textHeight();
        }

        String[] subs = textline.split(" ");

        for(int i=0;i&lt;subs.length;i++)    
        {
            String sub = subs[i];

            char lc1;
            boolean lbflag = false;
            boolean liflag = false;
            boolean luflag = false;

            while(!sub.isEmpty() &amp;&amp; ((lc1=sub.charAt(0))=='*' || lc1=='/' || lc1=='_') &amp;&amp; sub.charAt(sub.length()-1)==lc1)
            {
                sub = sub.substring(1,sub.length()-1);

                switch(lc1)
                {
                    case '*':
                    {
                        lbflag = true;

                        break;
                    }
                    case '/':
                    {
                        liflag = true;

                        break;
                    }
                    case '_':
                    {
                        luflag = true;

                        break;
                    }
                }
            }

            String word = lbflag || gbflag ? '*'+sub+'*' : sub;
            word = liflag || giflag ? '/'+word+'/' : word;
            word = luflag || guflag ? '_'+word+'_' : word;

            x += textWidth(sub,true);

            if(lbflag || gbflag)
            {
                x+=(word.length()/3);
            }

            if(!sub.trim().isEmpty())
            {   // No need to print empty words.
                // AlignHorizontal.RIGHT, that's to workaround an internal bug.
                com.baselet.control.HandlerElementMap.getHandlerForElement(this).getFontHandler().writeText(g2,word,(int)(x*zoom),(int)(y*zoom),com.baselet.control.enums.AlignHorizontal.RIGHT,true);
            }

            if(i&lt;subs.length-1)
            {   // Move the cusrsor one space right.
                x += textWidth(" ",true);
            }           
        }
    }
}
catch(Exception e)
{}</custom_code>
  </element>
</diagram>
